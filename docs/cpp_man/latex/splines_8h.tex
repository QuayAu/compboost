\hypertarget{splines_8h}{}\section{C\+:/\+Users/schal/\+One\+Drive/github\+\_\+repos/compboost/src/splines.h File Reference}
\label{splines_8h}\index{C\+:/\+Users/schal/\+One\+Drive/github\+\_\+repos/compboost/src/splines.\+h@{C\+:/\+Users/schal/\+One\+Drive/github\+\_\+repos/compboost/src/splines.\+h}}
{\ttfamily \#include $<$Rcpp\+Armadillo.\+h$>$}\newline
Include dependency graph for splines.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=206pt]{splines_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{splines_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
arma\+::mat \mbox{\hyperlink{splines_8h_add35190bf14503fafae37da8ff69eeec}{penalty\+Mat}} (const unsigned int \&, const unsigned int \&)
\begin{DoxyCompactList}\small\item\em Calculating penalty matrix. \end{DoxyCompactList}\item 
unsigned int \mbox{\hyperlink{splines_8h_a29ec9fa6acf5b1afbf860968368fc9d9}{find\+Span}} (const double \&, const arma\+::vec \&)
\begin{DoxyCompactList}\small\item\em Binary search to find index of given point within knots. \end{DoxyCompactList}\item 
arma\+::vec \mbox{\hyperlink{splines_8h_a5c5acc4a41114729ca30d3a49ba0365d}{create\+Knots}} (const arma\+::vec \&, const unsigned int \&, const unsigned int \&)
\begin{DoxyCompactList}\small\item\em Create knots for a specific number, degree and values. \end{DoxyCompactList}\item 
arma\+::mat \mbox{\hyperlink{splines_8h_a337394c7b0e3d15a0fd43f1b2dce4767}{create\+Spline\+Basis}} (const arma\+::vec \&, const unsigned int \&, const arma\+::vec \&)
\begin{DoxyCompactList}\small\item\em Transformation from a vector of input points to matrix of basis. \end{DoxyCompactList}\item 
arma\+::sp\+\_\+mat \mbox{\hyperlink{splines_8h_ac48ccbc9a36de85b7f1616a7fcf6b870}{create\+Sparse\+Spline\+Basis}} (const arma\+::vec \&, const unsigned int \&, const arma\+::vec \&)
\begin{DoxyCompactList}\small\item\em Transformation from a vector of input points to sparse matrix of basis. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{splines_8h_a5c5acc4a41114729ca30d3a49ba0365d}\label{splines_8h_a5c5acc4a41114729ca30d3a49ba0365d}} 
\index{splines.\+h@{splines.\+h}!create\+Knots@{create\+Knots}}
\index{create\+Knots@{create\+Knots}!splines.\+h@{splines.\+h}}
\subsubsection{\texorpdfstring{create\+Knots()}{createKnots()}}
{\footnotesize\ttfamily arma\+::vec create\+Knots (\begin{DoxyParamCaption}\item[{const arma\+::vec \&}]{values,  }\item[{const unsigned int \&}]{n\+\_\+knots,  }\item[{const unsigned int \&}]{degree }\end{DoxyParamCaption})}



Create knots for a specific number, degree and values. 

This functions takes a vector of points and creates knots used for the splines depending on the number of knots and degree. This function just handles equidistant knots.


\begin{DoxyParams}{Parameters}
{\em values} & {\ttfamily arma\+::vec} Points to create the basis matrix. \\
\hline
{\em n\+\_\+knots} & {\ttfamily unsigned int} Number of innter knots. \\
\hline
{\em degree} & {\ttfamily unsigned int} polynomial degree of splines.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily arma\+::vec} of knots. 
\end{DoxyReturn}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{splines_8h_a5c5acc4a41114729ca30d3a49ba0365d_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{splines_8h_ac48ccbc9a36de85b7f1616a7fcf6b870}\label{splines_8h_ac48ccbc9a36de85b7f1616a7fcf6b870}} 
\index{splines.\+h@{splines.\+h}!create\+Sparse\+Spline\+Basis@{create\+Sparse\+Spline\+Basis}}
\index{create\+Sparse\+Spline\+Basis@{create\+Sparse\+Spline\+Basis}!splines.\+h@{splines.\+h}}
\subsubsection{\texorpdfstring{create\+Sparse\+Spline\+Basis()}{createSparseSplineBasis()}}
{\footnotesize\ttfamily arma\+::sp\+\_\+mat create\+Sparse\+Spline\+Basis (\begin{DoxyParamCaption}\item[{const arma\+::vec \&}]{values,  }\item[{const unsigned int \&}]{degree,  }\item[{const arma\+::vec \&}]{knots }\end{DoxyParamCaption})}



Transformation from a vector of input points to sparse matrix of basis. 

This functions takes a vector of points and create a sparse matrix of basis functions. Each row contains the basis of the corresponding value in {\ttfamily values}.

Instead of calculating each row through a helper function we directly calculate deboors algorithm here. This is due to the procedure how sparse matrices should be allocated and constructed.


\begin{DoxyParams}{Parameters}
{\em param} & values {\ttfamily arma\+::vec} Points to create the basis matrix. \\
\hline
{\em param} & n\+\_\+knots {\ttfamily unsigned int} Number of innter knots. \\
\hline
{\em param} & degree {\ttfamily unsigned int} polynomial degree of splines.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily arma\+::sp\+\_\+mat} sparse matrix of base functions. 
\end{DoxyReturn}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=297pt]{splines_8h_ac48ccbc9a36de85b7f1616a7fcf6b870_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{splines_8h_ac48ccbc9a36de85b7f1616a7fcf6b870_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{splines_8h_a337394c7b0e3d15a0fd43f1b2dce4767}\label{splines_8h_a337394c7b0e3d15a0fd43f1b2dce4767}} 
\index{splines.\+h@{splines.\+h}!create\+Spline\+Basis@{create\+Spline\+Basis}}
\index{create\+Spline\+Basis@{create\+Spline\+Basis}!splines.\+h@{splines.\+h}}
\subsubsection{\texorpdfstring{create\+Spline\+Basis()}{createSplineBasis()}}
{\footnotesize\ttfamily arma\+::mat create\+Spline\+Basis (\begin{DoxyParamCaption}\item[{const arma\+::vec \&}]{values,  }\item[{const unsigned int \&}]{degree,  }\item[{const arma\+::vec \&}]{knots }\end{DoxyParamCaption})}



Transformation from a vector of input points to matrix of basis. 

This functions takes a vector of points and create a matrix of basis functions. Each row contains the basis of the corresponding value in {\ttfamily values}.


\begin{DoxyParams}{Parameters}
{\em values} & {\ttfamily arma\+::vec} Points to create the basis matrix. \\
\hline
{\em n\+\_\+knots} & {\ttfamily unsigned int} Number of innter knots. \\
\hline
{\em degree} & {\ttfamily unsigned int} polynomial degree of splines.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily sp\+\_\+mat} sparse matrix of base functions. 
\end{DoxyReturn}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=266pt]{splines_8h_a337394c7b0e3d15a0fd43f1b2dce4767_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{splines_8h_a337394c7b0e3d15a0fd43f1b2dce4767_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{splines_8h_a29ec9fa6acf5b1afbf860968368fc9d9}\label{splines_8h_a29ec9fa6acf5b1afbf860968368fc9d9}} 
\index{splines.\+h@{splines.\+h}!find\+Span@{find\+Span}}
\index{find\+Span@{find\+Span}!splines.\+h@{splines.\+h}}
\subsubsection{\texorpdfstring{find\+Span()}{findSpan()}}
{\footnotesize\ttfamily unsigned int find\+Span (\begin{DoxyParamCaption}\item[{const double \&}]{x,  }\item[{const arma\+::vec \&}]{knots }\end{DoxyParamCaption})}



Binary search to find index of given point within knots. 

This small functions search for the position of {\ttfamily x} within the {\ttfamily knots} and returns the smalles index for which x $>$= knots\mbox{[}i\mbox{]}.

Note that this function returns the {\ttfamily C++} index which starts with {\ttfamily 0} and ends with {\ttfamily n-\/1}.


\begin{DoxyParams}{Parameters}
{\em x} & {\ttfamily double} Point to search for position in knots. \\
\hline
{\em knots} & {\ttfamily arma\+::vec} Vector of knots. It\textquotesingle{}s the users responsibility to pass a {\bfseries S\+O\+R\+T\+ED} vector.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily unsigned int} of position of {\ttfamily x} in {\ttfamily knots}. 
\end{DoxyReturn}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{splines_8h_a29ec9fa6acf5b1afbf860968368fc9d9_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{splines_8h_add35190bf14503fafae37da8ff69eeec}\label{splines_8h_add35190bf14503fafae37da8ff69eeec}} 
\index{splines.\+h@{splines.\+h}!penalty\+Mat@{penalty\+Mat}}
\index{penalty\+Mat@{penalty\+Mat}!splines.\+h@{splines.\+h}}
\subsubsection{\texorpdfstring{penalty\+Mat()}{penaltyMat()}}
{\footnotesize\ttfamily arma\+::mat penalty\+Mat (\begin{DoxyParamCaption}\item[{const unsigned int \&}]{nparams,  }\item[{const unsigned int \&}]{differences }\end{DoxyParamCaption})}



Calculating penalty matrix. 

This function calculates the penalty matrix for a given number of parameters ({\ttfamily nparams}) and a given number of differences ({\ttfamily differences}).


\begin{DoxyParams}{Parameters}
{\em nparams} & {\ttfamily unsigned int} Number of params which should be penalized. This also pretend the number of rows and columns.\\
\hline
{\em differences} & {\ttfamily unsigned int} Number of penalized differences.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily arma\+::sp\+\_\+mat} Sparse penalty matrix used for p splines. 
\end{DoxyReturn}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{splines_8h_add35190bf14503fafae37da8ff69eeec_icgraph}
\end{center}
\end{figure}
