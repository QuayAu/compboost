\hypertarget{splines_8cpp}{}\section{E\+:/\+One\+Drive/\+Git\+Hub\+\_\+repos/compboost/src/splines.cpp File Reference}
\label{splines_8cpp}\index{E\+:/\+One\+Drive/\+Git\+Hub\+\_\+repos/compboost/src/splines.\+cpp@{E\+:/\+One\+Drive/\+Git\+Hub\+\_\+repos/compboost/src/splines.\+cpp}}
{\ttfamily \#include \char`\"{}splines.\+h\char`\"{}}\newline
Include dependency graph for splines.\+cpp\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=193pt]{splines_8cpp__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
arma\+::mat \mbox{\hyperlink{splines_8cpp_ab7f1f66c6e47e61810120b41dae2956d}{penalty\+Mat}} (const unsigned int \&nparams, const unsigned int \&differences)
\begin{DoxyCompactList}\small\item\em Calculating penalty matrix. \end{DoxyCompactList}\item 
unsigned int \mbox{\hyperlink{splines_8cpp_a5e4d339339067981aad8b6f39695ad7b}{find\+Span}} (const double \&x, const arma\+::vec \&knots)
\begin{DoxyCompactList}\small\item\em Binary search to find index of given point within knots. \end{DoxyCompactList}\item 
arma\+::rowvec \mbox{\hyperlink{splines_8cpp_ab5674a405e1cfc5b8e04ae2d113b9868}{basis\+Funs}} (const double \&x, const unsigned int \&degree, const arma\+::vec \&knots)
\begin{DoxyCompactList}\small\item\em De Boors algorithm to find basis functions. \end{DoxyCompactList}\item 
arma\+::vec \mbox{\hyperlink{splines_8cpp_ab51b53f392c4013697c072d010b250e4}{create\+Knots}} (const arma\+::vec \&values, const unsigned int \&n\+\_\+knots, const unsigned int \&degree)
\begin{DoxyCompactList}\small\item\em Create knots for a specific number, degree and values. \end{DoxyCompactList}\item 
arma\+::mat \mbox{\hyperlink{splines_8cpp_ac43a2b9f7f3a9589acb14ff221a3fc0e}{create\+Basis}} (const arma\+::vec \&values, const unsigned int \&degree, const arma\+::vec \&knots)
\begin{DoxyCompactList}\small\item\em Transformation from a vector of input points to sparse matrix of basis. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{splines_8cpp_ab5674a405e1cfc5b8e04ae2d113b9868}\label{splines_8cpp_ab5674a405e1cfc5b8e04ae2d113b9868}} 
\index{splines.\+cpp@{splines.\+cpp}!basis\+Funs@{basis\+Funs}}
\index{basis\+Funs@{basis\+Funs}!splines.\+cpp@{splines.\+cpp}}
\subsubsection{\texorpdfstring{basis\+Funs()}{basisFuns()}}
{\footnotesize\ttfamily arma\+::rowvec basis\+Funs (\begin{DoxyParamCaption}\item[{const double \&}]{x,  }\item[{const unsigned int \&}]{degree,  }\item[{const arma\+::vec \&}]{knots }\end{DoxyParamCaption})}



De Boors algorithm to find basis functions. 


\begin{DoxyParams}{Parameters}
{\em x} & {\ttfamily double} Point to search for position in knots. \\
\hline
{\em degree} & {\ttfamily unsigned int} Degree of the polynomial between the knots. \\
\hline
{\em knots} & {\ttfamily arma\+::vec} Vector of knots. It\textquotesingle{}s the users responsibility to pass a {\bfseries S\+O\+R\+T\+ED} vector.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily arma\+::sp\+\_\+mat} Sparse matrix containing the basis functions. 
\end{DoxyReturn}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=232pt]{splines_8cpp_ab5674a405e1cfc5b8e04ae2d113b9868_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{splines_8cpp_ab5674a405e1cfc5b8e04ae2d113b9868_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{splines_8cpp_ac43a2b9f7f3a9589acb14ff221a3fc0e}\label{splines_8cpp_ac43a2b9f7f3a9589acb14ff221a3fc0e}} 
\index{splines.\+cpp@{splines.\+cpp}!create\+Basis@{create\+Basis}}
\index{create\+Basis@{create\+Basis}!splines.\+cpp@{splines.\+cpp}}
\subsubsection{\texorpdfstring{create\+Basis()}{createBasis()}}
{\footnotesize\ttfamily arma\+::mat create\+Basis (\begin{DoxyParamCaption}\item[{const arma\+::vec \&}]{values,  }\item[{const unsigned int \&}]{degree,  }\item[{const arma\+::vec \&}]{knots }\end{DoxyParamCaption})}



Transformation from a vector of input points to sparse matrix of basis. 

This functions takes a vector of points and create a sparse matrix of basis functions. Each row contains the basis of the corresponding value in {\ttfamily values}.


\begin{DoxyParams}{Parameters}
{\em values} & {\ttfamily arma\+::vec} Points to create the basis matrix. \\
\hline
{\em n\+\_\+knots} & {\ttfamily unsigned int} Number of innter knots. \\
\hline
{\em degree} & {\ttfamily unsigned int} polynomial degree of splines.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily sp\+\_\+mat} sparse matrix of base functions. 
\end{DoxyReturn}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=336pt]{splines_8cpp_ac43a2b9f7f3a9589acb14ff221a3fc0e_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{splines_8cpp_ac43a2b9f7f3a9589acb14ff221a3fc0e_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{splines_8cpp_ab51b53f392c4013697c072d010b250e4}\label{splines_8cpp_ab51b53f392c4013697c072d010b250e4}} 
\index{splines.\+cpp@{splines.\+cpp}!create\+Knots@{create\+Knots}}
\index{create\+Knots@{create\+Knots}!splines.\+cpp@{splines.\+cpp}}
\subsubsection{\texorpdfstring{create\+Knots()}{createKnots()}}
{\footnotesize\ttfamily arma\+::vec create\+Knots (\begin{DoxyParamCaption}\item[{const arma\+::vec \&}]{values,  }\item[{const unsigned int \&}]{n\+\_\+knots,  }\item[{const unsigned int \&}]{degree }\end{DoxyParamCaption})}



Create knots for a specific number, degree and values. 

This functions takes a vector of points and creates knots used for the splines depending on the number of knots and degree. This function just handles equidistant knots.


\begin{DoxyParams}{Parameters}
{\em values} & {\ttfamily arma\+::vec} Points to create the basis matrix. \\
\hline
{\em n\+\_\+knots} & {\ttfamily unsigned int} Number of innter knots. \\
\hline
{\em degree} & {\ttfamily unsigned int} polynomial degree of splines.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily arma\+::vec} of knots. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=346pt]{splines_8cpp_ab51b53f392c4013697c072d010b250e4_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{splines_8cpp_a5e4d339339067981aad8b6f39695ad7b}\label{splines_8cpp_a5e4d339339067981aad8b6f39695ad7b}} 
\index{splines.\+cpp@{splines.\+cpp}!find\+Span@{find\+Span}}
\index{find\+Span@{find\+Span}!splines.\+cpp@{splines.\+cpp}}
\subsubsection{\texorpdfstring{find\+Span()}{findSpan()}}
{\footnotesize\ttfamily unsigned int find\+Span (\begin{DoxyParamCaption}\item[{const double \&}]{x,  }\item[{const arma\+::vec \&}]{knots }\end{DoxyParamCaption})}



Binary search to find index of given point within knots. 

This small functions search for the position of {\ttfamily x} within the {\ttfamily knots} and returns the smalles index for which x $>$= knots\mbox{[}i\mbox{]}.

Note that this function returns the {\ttfamily C++} index which starts with {\ttfamily 0} and ends with {\ttfamily n-\/1}.


\begin{DoxyParams}{Parameters}
{\em x} & {\ttfamily double} Point to search for position in knots. \\
\hline
{\em knots} & {\ttfamily arma\+::vec} Vector of knots. It\textquotesingle{}s the users responsibility to pass a {\bfseries S\+O\+R\+T\+ED} vector.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily unsigned int} of position of {\ttfamily x} in {\ttfamily knots}. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{splines_8cpp_a5e4d339339067981aad8b6f39695ad7b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{splines_8cpp_ab7f1f66c6e47e61810120b41dae2956d}\label{splines_8cpp_ab7f1f66c6e47e61810120b41dae2956d}} 
\index{splines.\+cpp@{splines.\+cpp}!penalty\+Mat@{penalty\+Mat}}
\index{penalty\+Mat@{penalty\+Mat}!splines.\+cpp@{splines.\+cpp}}
\subsubsection{\texorpdfstring{penalty\+Mat()}{penaltyMat()}}
{\footnotesize\ttfamily arma\+::mat penalty\+Mat (\begin{DoxyParamCaption}\item[{const unsigned int \&}]{nparams,  }\item[{const unsigned int \&}]{differences }\end{DoxyParamCaption})}



Calculating penalty matrix. 

This function calculates the penalty matrix for a given number of parameters ({\ttfamily nparams}) and a given number of differences ({\ttfamily differences}).


\begin{DoxyParams}{Parameters}
{\em nparams} & {\ttfamily unsigned int} Number of params which should be penalized. This also pretend the number of rows and columns.\\
\hline
{\em differences} & {\ttfamily unsigned int} Number of penalized differences.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily arma\+::sp\+\_\+mat} Sparse penalty matrix used for p splines. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=342pt]{splines_8cpp_ab7f1f66c6e47e61810120b41dae2956d_icgraph}
\end{center}
\end{figure}
